---
title: "Analyse de réseau avec `R`"
author: "Florian Cafiero"
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: pygments
    toc: true
    toc_float:
      toc_collapsed: true
    theme: united
---

<a style="float:right; width: 20%;" rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Licence Creative Commons" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a>

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hide', fig.show='hold')
```

0. Préparatifs
Dans cette première partie, nous allons préparer notre environnement de travail pour l'analyse de réseau avec R. Nous utiliserons les packages modernes du tidyverse, ainsi que tidygraph et ggraph pour manipuler et visualiser les graphes de manière efficace et intuitive.

0.1 Création d'un projet RStudio
Pour assurer la reproductibilité de notre travail, nous allons créer un projet RStudio dédié à ce cours.

Ouvrez RStudio.
Cliquez sur File > New Project... > New Directory > New Project.
Donnez un nom à votre projet, par exemple Analyse_Reseau.
Choisissez un emplacement sur votre ordinateur.
Cliquez sur Create Project.
0.2 Gestion des dépendances avec renv
Pour gérer les packages et assurer que tous les participants utilisent les mêmes versions, nous allons utiliser le package renv.

```{r, include=FALSE}
# Installation du package renv s'il n'est pas déjà installé
if(!require("renv")) install.packages("renv")
# Initialisation de renv dans le projet
renv::init(bare = TRUE)
```

Note : Lors de l'initialisation, renv peut vous demander de confirmer certaines actions. Lisez attentivement les messages et acceptez si nécessaire.

0.3 Installation et chargement des packages
Nous allons installer et charger les packages nécessaires pour ce cours. Nous utiliserons la syntaxe moderne du tidyverse et des packages spécialisés pour l'analyse de réseaux.

```{r,

# Liste des packages à installer
packages <- c("tidyverse", "tidygraph", "ggraph", "igraph", "visNetwork", "networkD3", "corrr", "sf", "leaflet")

# Installation des packages manquants
missing_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(missing_packages)) install.packages(missing_packages)

# Chargement des packages
lapply(packages, library, character.only = TRUE)

# Enregistrement des packages dans renv
renv::snapshot()
```

0.4 Chargement des données
Nous allons utiliser les mêmes données que précédemment, à savoir un fichier de nœuds (nodes.csv) et un fichier d'arêtes (edges.csv). Assurez-vous que ces fichiers sont présents dans le dossier data/basic de votre projet.

```{r,
# Chargement des données avec readr
nodes <- read_delim("data/basic/nodes.csv", delim = "\t", col_names = FALSE)
edges <- read_delim("data/basic/edges.csv", delim = "\t", col_names = FALSE)

# Attribution des noms de colonnes
colnames(nodes) <- c("id", "label", "type")
colnames(edges) <- c("from", "to")

# Vérification des données
head(nodes)
head(edges)
```

0.5 Vérification et préparation des données
Il est important de vérifier que nos données sont cohérentes et qu'il n'y a pas de doublons ou d'incohérences.

```{r,
# Nombre de nœuds et nœuds uniques
n_nodes <- nrow(nodes)
n_unique_nodes <- nodes %>% distinct(id) %>% nrow()

cat("Nombre de nœuds :", n_nodes, "\n")
cat("Nombre de nœuds uniques :", n_unique_nodes, "\n")

# Nombre d'arêtes et arêtes uniques
n_edges <- nrow(edges)
n_unique_edges <- edges %>% distinct(from, to) %>% nrow()

cat("Nombre d'arêtes :", n_edges, "\n")
cat("Nombre d'arêtes uniques :", n_unique_edges, "\n")
```

Si nous constatons des doublons dans les arêtes, nous pourrons les traiter plus tard en les transformant en poids.

0.6 Création du graphe avec tidygraph
Nous allons maintenant transformer ces données en un objet tbl_graph du package tidygraph, ce qui nous permettra de manipuler le graphe avec la syntaxe du tidyverse.

```{r,
library(tidygraph)
# Création du graphe
graph <- tbl_graph(nodes = nodes, edges = edges, directed = FALSE)
# Inspection du graphe
graph
```


0.7 Visualisation initiale avec ggraph
Pour visualiser rapidement notre graphe, nous pouvons utiliser le package ggraph, qui s'intègre parfaitement avec tidygraph.

```{r,
library(ggraph)

# Visualisation simple
ggraph(graph, layout = "fr") +
  geom_edge_link(alpha = 0.8) +
  geom_node_point() +
  theme_minimal()
```

# 1. Manipulation et exploration du réseau

Dans cette deuxième partie, nous allons explorer et analyser le réseau en utilisant les outils modernes de `tidygraph` et `ggraph`. Nous aborderons les mesures de centralité, la détection de communautés et d'autres analyses pertinentes pour les sciences humaines et sociales.

## 1.1 Simplification du réseau

Avant de commencer, nous allons simplifier le réseau en combinant les arêtes multiples et en supprimant les boucles si nécessaire.

```{r}
# Combiner les arêtes multiples en calculant le poids
graph_simplified <- graph %>%
  activate(edges) %>%
  mutate(weight = 1) %>%
  group_by(from, to) %>%
  summarise(weight = sum(weight)) %>%
  ungroup() %>%
  activate(nodes)
```

# Vérification
graph_simplified
1.2 Mesures de centralité
Nous allons calculer différentes mesures de centralité pour les nœuds du réseau : degré, proximité, intermédiarité et vecteur propre.

```{r,
library(tidygraph)

# Calcul des mesures de centralité
graph_centrality <- graph_simplified %>%
  mutate(
    degree = centrality_degree(mode = 'all'),
    closeness = centrality_closeness(),
    betweenness = centrality_betweenness(),
    eigen = centrality_eigen()
  )


# Affichage des premières lignes
graph_centrality %>% as_tibble() %>% head()
```

1.3 Visualisation des centralités
Nous pouvons visualiser le réseau en ajustant la taille ou la couleur des nœuds en fonction des mesures de centralité.

1.3.1 Centralité de degré

```{r,
library(ggraph)

# Visualisation avec la taille des nœuds proportionnelle au degré
ggraph(graph_centrality, layout = "fr") +
  geom_edge_link(alpha = 0.5) +
  geom_node_point(aes(size = degree, color = type)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_size_continuous(range = c(3, 10)) +
  theme_minimal() +
  labs(title = "Centralité de degré", size = "Degré", color = "Type")
```


1.3.2 Centralité d'intermédiarité

```{r,
# Visualisation avec la couleur des nœuds proportionnelle à l'intermédiarité
ggraph(graph_centrality, layout = "fr") +
  geom_edge_link(alpha = 0.5) +
  geom_node_point(aes(size = 5, color = betweenness)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Centralité d'intermédiarité", color = "Betweenness")
```

1.4 Détection de communautés
Nous allons détecter les communautés dans le réseau en utilisant l'algorithme de Louvain, qui est efficace pour les grands réseaux.

```{r,
# Détection des communautés
graph_communities <- graph_centrality %>%
  mutate(community = as.factor(group_louvain()))
```

# Affichage des communautés
graph_communities %>% as_tibble() %>% select(label, community) %>% head()
1.4.1 Visualisation des communautés
{r}
# Visualisation avec les communautés en couleur
ggraph(graph_communities, layout = "fr") +
  geom_edge_link(alpha = 0.2) +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  theme_minimal() +
  labs(title = "Détection de communautés (Louvain)", color = "Communauté", size = "Degré")
```

1.5 Analyse des communautés
Nous pouvons analyser la composition des communautés pour voir si elles correspondent à des types spécifiques ou à d'autres attributs.

```{r,
# Comptage des types par communauté
community_analysis <- graph_communities %>%
  as_tibble() %>%
  group_by(community, type) %>%
  summarise(count = n()) %>%
  arrange(community)

# Affichage
community_analysis
```


1.6 Chemins et distances
1.6.1 Plus court chemin entre deux nœuds
Nous pouvons calculer le plus court chemin entre deux individus, par exemple entre "Thomas Jolly" et "Pierre Corneille".

```{r,
# Identification des indices des nœuds
from_node <- which(V(graph_communities)$label == "Thomas Jolly")
to_node <- which(V(graph_communities)$label == "Pierre Corneille")

# Calcul du plus court chemin
shortest_path_nodes <- shortest_paths(graph_communities, from = from_node, to = to_node)$vpath[[1]]

# Marquage des nœuds et arêtes du chemin
graph_paths <- graph_communities %>%
  mutate(is_in_path = ifelse(node_is_in(shortest_path_nodes), TRUE, FALSE)) %>%
  activate(edges) %>%
  mutate(is_in_path = edge_is_between(from = shortest_path_nodes))

# Visualisation du chemin
ggraph(graph_paths, layout = "fr") +
  geom_edge_link(aes(color = is_in_path), alpha = 0.5) +
  geom_node_point(aes(color = is_in_path), size = 5) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "red")) +
  theme_minimal() +
  labs(title = "Plus court chemin entre Thomas Jolly et Pierre Corneille", color = "Dans le chemin")
```


1.6.2 Matrice des distances
Nous pouvons également calculer la matrice des distances entre tous les nœuds.

```{r,
# Matrice des distances
distance_matrix <- graph_communities %>% 
  convert(to_undirected) %>% 
  distances()

# Affichage de la matrice pour les premiers nœuds
distance_matrix[1:5, 1:5]
```


1.7 Distribution des degrés
Analyser la distribution des degrés peut nous informer sur la structure du réseau.

```{r,
# Distribution des degrés
degree_distribution <- graph_centrality %>%
  as_tibble() %>%
  ggplot(aes(x = degree)) +
  geom_histogram(binwidth = 1, fill = "skyblue", color = "black") +
  theme_minimal() +
  labs(title = "Distribution des degrés", x = "Degré", y = "Fréquence")

degree_distribution
```

1.8 Sauvegarde des résultats
Il est important de sauvegarder les données enrichies pour une utilisation ultérieure.

```{r,

# Sauvegarde des données enrichies
write_csv(as_tibble(graph_communities), "data/graph_nodes_enriched.csv")
write_csv(as_tibble(graph_communities %>% activate(edges)), "data/graph_edges_enriched.csv")
```

# 2. Visualisation avancée et interactive

Dans cette troisième partie, nous allons nous concentrer sur la visualisation avancée du réseau en utilisant des techniques interactives pour mieux explorer et présenter les données. Nous utiliserons principalement les packages `ggraph`, `plotly`, `visNetwork` et `leaflet`.

## 2.1 Visualisations avancées avec `ggraph`

Nous allons personnaliser davantage nos graphiques en utilisant les fonctionnalités avancées de `ggraph`.

### 2.1.1 Personnalisation des layouts

```{r,
# Utilisation du layout 'stress' pour une meilleure répartition des nœuds
ggraph(graph_communities, layout = "stress") +
  geom_edge_link(aes(edge_width = weight), alpha = 0.5, color = "grey") +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_edge_width(range = c(0.2, 2)) +
  theme_graph() +
  labs(title = "Visualisation avancée avec le layout 'stress'",
       edge_width = "Poids des arêtes",
       color = "Communauté",
       size = "Degré")
```



2.1.2 Utilisation de palettes de couleurs
```{r,

# Installation du package RColorBrewer si nécessaire
if(!require("RColorBrewer")) install.packages("RColorBrewer")
library(RColorBrewer)

# Choix d'une palette de couleurs
palette <- brewer.pal(n = length(unique(graph_communities$community)), name = "Set2")

# Application de la palette
ggraph(graph_communities, layout = "fr") +
  geom_edge_link(alpha = 0.3, color = "grey") +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_color_manual(values = palette) +
  theme_graph() +
  labs(title = "Visualisation avec une palette personnalisée",
       color = "Communauté",
       size = "Degré")
```

2.1.3 Visualisation hiérarchique
Si le réseau a une structure hiérarchique, nous pouvons utiliser un layout adapté.

```{r,
# Utilisation du layout 'dendrogramme' après avoir converti le graphe
graph_tree <- graph_communities %>% 
  convert(to_tree, mode = "undirected")

ggraph(graph_tree, layout = "dendrogram", circular = FALSE) +
  geom_edge_diagonal() +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), hjust = -0.1, size = 3) +
  theme_graph() +
  labs(title = "Visualisation hiérarchique du réseau",
       color = "Communauté",
       size = "Degré")
```


2.2 Visualisation interactive avec plotly
Nous pouvons rendre nos graphiques interactifs en utilisant plotly, ce qui permet d'afficher des informations supplémentaires au survol des nœuds.

```{r,
Copier le code
library(plotly)

# Création d'un graphique interactif
p <- ggraph(graph_communities, layout = "fr") +
  geom_edge_link(alpha = 0.3, color = "grey") +
  geom_node_point(aes(color = community, size = degree, text = paste("Nom:", label, "<br>Type:", type))) +
  theme_void()

# Conversion en graphique interactif
ggplotly(p, tooltip = "text")
```


2.3 Visualisation interactive avec visNetwork
Le package visNetwork permet de créer des visualisations interactives et dynamiques.

2.3.1 Préparation des données
```{r,
library(visNetwork)

# Conversion des données pour visNetwork
nodes_vis <- graph_communities %>%
  as_tibble() %>%
  mutate(id = id,
         label = label,
         group = community,
         title = paste0("<p><b>", label, "</b><br>Type: ", type, "<br>Degré: ", degree, "</p>"))

edges_vis <- graph_communities %>%
  activate(edges) %>%
  as_tibble()

# Vérification
head(nodes_vis)
head(edges_vis)
```



2.3.2 Création du réseau interactif
```{r,
# Création du réseau interactif
visNetwork(nodes_vis, edges_vis) %>%
  visNodes(scaling = list(min = 10, max = 30)) %>%
  visEdges(scaling = list(min = 1, max = 10)) %>%
  visOptions(highlightNearest = list(enabled = TRUE, degree = 1),
             nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = 42) %>%
  visPhysics(stabilization = FALSE) %>%
  visLegend()
```

2.4 Visualisation géographique avec sf et leaflet
Si vos données comprennent des coordonnées géographiques, vous pouvez les visualiser sur une carte interactive.

2.4.1 Chargement des données géographiques
```{r,
# Chargement des données géographiques
nodes_geo <- read_delim("data/geo/nodes.csv", delim = "\t", col_names = FALSE)
edges_geo <- read_delim("data/geo/edges.csv", delim = "\t", col_names = FALSE)

colnames(nodes_geo) <- c("id", "label", "lat", "lon")
colnames(edges_geo) <- c("from", "to")

# Conversion en objet sf
nodes_sf <- st_as_sf(nodes_geo, coords = c("lon", "lat"), crs = 4326)
```


2.4.2 Création du graphe géographique

```{r,
# Création du graphe avec tidygraph
graph_geo <- tbl_graph(nodes = nodes_geo, edges = edges_geo, directed = FALSE)

# Ajout des coordonnées géographiques
graph_geo <- graph_geo %>%
  activate(nodes) %>%
  mutate(lon = as.numeric(lon), lat = as.numeric(lat))
```


2.4.3 Visualisation avec leaflet
```{r,
library(leaflet)

# Création de la carte interactive
leaflet() %>%
  addTiles() %>%
  addCircleMarkers(data = nodes_geo, ~lon, ~lat,
                   label = ~label,
                   color = "blue",
                   radius = 5) %>%
  addPolylines(data = edges_geo %>%
                 left_join(nodes_geo, by = c("from" = "id")) %>%
                 rename(lon_from = lon, lat_from = lat) %>%
                 left_join(nodes_geo, by = c("to" = "id")) %>%
                 rename(lon_to = lon, lat_to = lat),
               lng = ~c(lon_from, lon_to),
               lat = ~c(lat_from, lat_to),
               color = "grey")
```


2.5 Sauvegarde et exportation des visualisations
2.5.1 Sauvegarde des graphiques statiques
```{r,
# Sauvegarde du dernier graphique ggplot en PNG
ggsave("visualisation_avancee.png", width = 10, height = 8, dpi = 300)

# Sauvegarde en PDF
ggsave("visualisation_avancee.pdf", width = 10, height = 8)
```

2.5.2 Exportation des visualisations interactives
Vous pouvez exporter vos visualisations interactives au format HTML pour les partager.

```{r,

# Sauvegarde du graphique plotly
htmlwidgets::saveWidget(ggplotly(p, tooltip = "text"), "graphique_interactif.html")

# Sauvegarde du réseau visNetwork
visSave(
  visNetwork(nodes_vis, edges_vis) %>%
    visNodes(scaling = list(min = 10, max = 30)) %>%
    visEdges(scaling = list(min = 1, max = 10)) %>%
    visOptions(highlightNearest = list(enabled = TRUE, degree = 1),
               nodesIdSelection = TRUE) %>%
    visLayout(randomSeed = 42) %>%
    visPhysics(stabilization = FALSE) %>%
    visLegend(),
  file = "reseau_interactif.html"
)
```

2.5.3 Exportation des cartes interactives
```{r,
# Sauvegarde de la carte leaflet
library(htmlwidgets)
saveWidget(leaflet() %>%
             addTiles() %>%
             addCircleMarkers(data = nodes_geo, ~lon, ~lat,
                              label = ~label,
                              color = "blue",
                              radius = 5) %>%
             addPolylines(data = edges_geo %>%
                            left_join(nodes_geo, by = c("from" = "id")) %>%
                            rename(lon_from = lon, lat_from = lat) %>%
                            left_join(nodes_geo, by = c("to" = "id")) %>%
                            rename(lon_to = lon, lat_to = lat),
                          lng = ~c(lon_from, lon_to),
                          lat = ~c(lat_from, lat_to),
                          color = "grey"),
           "carte_interactive.html")
```

# 2. Visualisation avancée et interactive

Dans cette troisième partie, nous allons nous concentrer sur la visualisation avancée du réseau en utilisant des techniques interactives pour mieux explorer et présenter les données. Nous utiliserons principalement les packages `ggraph`, `plotly`, `visNetwork` et `leaflet`.

## 2.1 Visualisations avancées avec `ggraph`

Nous allons personnaliser davantage nos graphiques en utilisant les fonctionnalités avancées de `ggraph`.

### 2.1.1 Personnalisation des layouts

```{r}
# Utilisation du layout 'stress' pour une meilleure répartition des nœuds
ggraph(graph_communities, layout = "stress") +
  geom_edge_link(aes(edge_width = weight), alpha = 0.5, color = "grey") +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_edge_width(range = c(0.2, 2)) +
  theme_graph() +
  labs(title = "Visualisation avancée avec le layout 'stress'",
       edge_width = "Poids des arêtes",
       color = "Communauté",
       size = "Degré")
```

2.1.2 Utilisation de palettes de couleurs
```{r,
# Installation du package RColorBrewer si nécessaire
if(!require("RColorBrewer")) install.packages("RColorBrewer")
library(RColorBrewer)

# Choix d'une palette de couleurs
palette <- brewer.pal(n = length(unique(graph_communities$community)), name = "Set2")

# Application de la palette
ggraph(graph_communities, layout = "fr") +
  geom_edge_link(alpha = 0.3, color = "grey") +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), repel = TRUE, size = 3) +
  scale_color_manual(values = palette) +
  theme_graph() +
  labs(title = "Visualisation avec une palette personnalisée",
       color = "Communauté",
       size = "Degré")
```


2.1.3 Visualisation hiérarchique
Si le réseau a une structure hiérarchique, nous pouvons utiliser un layout adapté.

```{r,
# Utilisation du layout 'dendrogramme' après avoir converti le graphe
graph_tree <- graph_communities %>% 
  convert(to_tree, mode = "undirected")

ggraph(graph_tree, layout = "dendrogram", circular = FALSE) +
  geom_edge_diagonal() +
  geom_node_point(aes(color = community, size = degree)) +
  geom_node_text(aes(label = label), hjust = -0.1, size = 3) +
  theme_graph() +
  labs(title = "Visualisation hiérarchique du réseau",
       color = "Communauté",
       size = "Degré")
```

2.2 Visualisation interactive avec plotly
Nous pouvons rendre nos graphiques interactifs en utilisant plotly, ce qui permet d'afficher des informations supplémentaires au survol des nœuds.

```{r,
library(plotly)

# Création d'un graphique interactif
p <- ggraph(graph_communities, layout = "fr") +
  geom_edge_link(alpha = 0.3, color = "grey") +
  geom_node_point(aes(color = community, size = degree, text = paste("Nom:", label, "<br>Type:", type))) +
  theme_void()

# Conversion en graphique interactif
ggplotly(p, tooltip = "text")
```

2.3 Visualisation interactive avec visNetwork
Le package visNetwork permet de créer des visualisations interactives et dynamiques.

2.3.1 Préparation des données
```{r,
library(visNetwork)

# Conversion des données pour visNetwork
nodes_vis <- graph_communities %>%
  as_tibble() %>%
  mutate(id = id,
         label = label,
         group = community,
         title = paste0("<p><b>", label, "</b><br>Type: ", type, "<br>Degré: ", degree, "</p>"))

edges_vis <- graph_communities %>%
  activate(edges) %>%
  as_tibble()

# Vérification
head(nodes_vis)
head(edges_vis)
```

2.3.2 Création du réseau interactif
```{r,
# Création du réseau interactif
visNetwork(nodes_vis, edges_vis) %>%
  visNodes(scaling = list(min = 10, max = 30)) %>%
  visEdges(scaling = list(min = 1, max = 10)) %>%
  visOptions(highlightNearest = list(enabled = TRUE, degree = 1),
             nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = 42) %>%
  visPhysics(stabilization = FALSE) %>%
  visLegend()
```

2.4 Visualisation géographique avec sf et leaflet
Si vos données comprennent des coordonnées géographiques, vous pouvez les visualiser sur une carte interactive.

2.4.1 Chargement des données géographiques
```{r,
# Chargement des données géographiques
nodes_geo <- read_delim("data/geo/nodes.csv", delim = "\t", col_names = FALSE)
edges_geo <- read_delim("data/geo/edges.csv", delim = "\t", col_names = FALSE)

colnames(nodes_geo) <- c("id", "label", "lat", "lon")
colnames(edges_geo) <- c("from", "to")

# Conversion en objet sf
nodes_sf <- st_as_sf(nodes_geo, coords = c("lon", "lat"), crs = 4326)
```

2.4.2 Création du graphe géographique
```{r,
# Création du graphe avec tidygraph
graph_geo <- tbl_graph(nodes = nodes_geo, edges = edges_geo, directed = FALSE)

# Ajout des coordonnées géographiques
graph_geo <- graph_geo %>%
  activate(nodes) %>%
  mutate(lon = as.numeric(lon), lat = as.numeric(lat))
```

2.4.3 Visualisation avec leaflet
```{r,
library(leaflet)

# Création de la carte interactive
leaflet() %>%
  addTiles() %>%
  addCircleMarkers(data = nodes_geo, ~lon, ~lat,
                   label = ~label,
                   color = "blue",
                   radius = 5) %>%
  addPolylines(data = edges_geo %>%
                 left_join(nodes_geo, by = c("from" = "id")) %>%
                 rename(lon_from = lon, lat_from = lat) %>%
                 left_join(nodes_geo, by = c("to" = "id")) %>%
                 rename(lon_to = lon, lat_to = lat),
               lng = ~c(lon_from, lon_to),
               lat = ~c(lat_from, lat_to),
               color = "grey")
```


2.5 Sauvegarde et exportation des visualisations
2.5.1 Sauvegarde des graphiques statiques
```{r,
# Sauvegarde du dernier graphique ggplot en PNG
ggsave("visualisation_avancee.png", width = 10, height = 8, dpi = 300)

# Sauvegarde en PDF
ggsave("visualisation_avancee.pdf", width = 10, height = 8)
```


2.5.2 Exportation des visualisations interactives
Vous pouvez exporter vos visualisations interactives au format HTML pour les partager.

```{r,
# Sauvegarde du graphique plotly
htmlwidgets::saveWidget(ggplotly(p, tooltip = "text"), "graphique_interactif.html")

# Sauvegarde du réseau visNetwork
visSave(
  visNetwork(nodes_vis, edges_vis) %>%
    visNodes(scaling = list(min = 10, max = 30)) %>%
    visEdges(scaling = list(min = 1, max = 10)) %>%
    visOptions(highlightNearest = list(enabled = TRUE, degree = 1),
               nodesIdSelection = TRUE) %>%
    visLayout(randomSeed = 42) %>%
    visPhysics(stabilization = FALSE) %>%
    visLegend(),
  file = "reseau_interactif.html"
)
```

2.5.3 Exportation des cartes interactives
```{r,
# Sauvegarde de la carte leaflet
library(htmlwidgets)
saveWidget(leaflet() %>%
             addTiles() %>%
             addCircleMarkers(data = nodes_geo, ~lon, ~lat,
                              label = ~label,
                              color = "blue",
                              radius = 5) %>%
             addPolylines(data = edges_geo %>%
                            left_join(nodes_geo, by = c("from" = "id")) %>%
                            rename(lon_from = lon, lat_from = lat) %>%
                            left_join(nodes_geo, by = c("to" = "id")) %>%
                            rename(lon_to = lon, lat_to = lat),
                          lng = ~c(lon_from, lon_to),
                          lat = ~c(lat_from, lat_to),
                          color = "grey"),
           "carte_interactive.html")
```

2.6 Conclusion
Nous avons exploré différentes méthodes pour visualiser et interagir avec les réseaux en R. Les outils modernes comme ggraph, plotly, visNetwork et leaflet offrent de nombreuses possibilités pour analyser et présenter vos données de manière efficace et esthétique.

N'hésitez pas à explorer davantage ces packages et à les adapter à vos propres données et besoins en recherche.








